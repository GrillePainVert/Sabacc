#include "model.h"
#include "logger.h"

void PaquetSabacc::appliqueDistribution(const uint32_t dist[NB_CARTES]) {  
   
   // Copopie la distribution de cartes
   m_nbCartesRestantes = 0;

   for (uint32_t i = 0; i < NB_CARTES; ++i) {  
       m_distribution[i] = dist[i];  
       m_nbCartesRestantes += dist[i];
   }  
   
}

void PaquetSabacc::reset()
{         
    appliqueDistribution(DISTRIBUTION_PAQUET_INITIAL);
}


uint32_t PaquetSabacc::getNbCartes() const
{
    return m_nbCartesRestantes;
}

Carte PaquetSabacc::pioche(PCGAlea& rng)
{
    if (m_nbCartesRestantes == 0) {
        // Paquet vide, retourner une carte indéfinie
        return Carte::C_INDEFINI;
    }

    // Sélection d'une carte aléatoire
    uint32_t index = rng.aleaInferieurA(m_nbCartesRestantes);
    uint32_t type = 0;

    while (true) {
        if (m_distribution[type] > index) {
            break;  // Nous avons trouvé le type
        }
        index -= m_distribution[type];
        type++;
        // Note: Pas besoin de vérifier si type < 8 car le total est correct
    }

    // Décrémenter le compteur pour ce type de carte
    m_distribution[type]--;
    m_nbCartesRestantes--;

    return static_cast<Carte>(type);
}

PCGAlea::PCGAlea(uint64_t graine): state(graine), inc(54 | 1)
{
}

//Méthode pour générer un nombre aléatoire
uint32_t PCGAlea::alea()
{
    uint64_t oldState = state;
    state = oldState * 6364136223846793005ULL + inc;
    uint32_t xorshifted = (uint32_t)(((oldState >> 18u) ^ oldState) >> 27u);
    uint32_t rot = oldState >> 59u;
    return (xorshifted >> rot) | (xorshifted << ((-(int32_t)rot) & 31));	
}

// Méthode pour générer un nombre borné dans [0, borne[
uint32_t PCGAlea::aleaInferieurA(uint32_t borne)
{
    uint32_t threshold = (~borne + 1u) % borne;
    uint32_t r;
    do {
        r = alea();
    } while (r < threshold);
    return r % borne;
}

void DefausseSabacc::vide()
{
    nbCartes = 0;
}

void DefausseSabacc::defausse(Carte c)
{
    cartesDefausse[nbCartes] = c;
    nbCartes++;
}

uint32_t DefausseSabacc::getNbCartes() const
{
    return nbCartes;
}

Carte DefausseSabacc::pioche()
{
    if (nbCartes == 0) {
        //pioche vide
        LOGWARNING << u8"ATTENTION pioche vide!" << std::endl;
        return C_INDEFINI;
    }

    nbCartes--;
    return cartesDefausse[nbCartes];
}

Carte DefausseSabacc::regarde() const
{
    if (nbCartes == 0) {
        //pioche vide
        LOGWARNING << u8"ATTENTION pioche vide!" << std::endl;
        return C_INDEFINI;
    }
    return cartesDefausse[nbCartes-1];    
}

void JeuSabacc::initJeu(PCGAlea& rng)
{
    m_manche = 0;
    LOGDEBUG<< u8"début jeu, tirage influences, ";
    
    // Tirage au sort des 3 jetons d'influence disponibles
    JetonInfluence tousLesJetons[NB_JETONS_INFLUENCE];
    for (uint32_t i = 0; i < NB_JETONS_INFLUENCE; ++i) {
        tousLesJetons[i] = static_cast<JetonInfluence>(i);
    }
    // Mélange des jetons (Fisher-Yates)
    for (uint32_t i = NB_JETONS_INFLUENCE - 1; i > 0; --i) {
        uint32_t j = rng.aleaInferieurA(i + 1);
        std::swap(tousLesJetons[i], tousLesJetons[j]);
    }
    // Sélection des 3 premiers jetons
    for (uint32_t i = 0; i < 3; ++i) {
        m_jetonsTiresAuSort[i] = tousLesJetons[i];
    }
    
    LOGDEBUG << u8"init joueurs" <<std::endl;
    for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
        // Réinitialiser le joueur        
        m_joueurs[i].m_reserve = RESERVE_TAILLE; // Chaque joueur commence avec 8 jetons
        m_joueurs[i].m_enJeu = true;

        // Attribuer les jetons d'influence
        for (int j = 0; j < 3; ++j) {
            m_joueurs[i].m_jetonsInfluence[j] = m_jetonsTiresAuSort[j];
        }
    }

    initManche(rng);
}

void JeuSabacc::initManche(PCGAlea& rng)
{
    //augmente manche, mets tour à 1    
    m_manche++;
    m_tour = 0;
    LOGDEBUG << u8"début manche: " << m_manche << ", ";

    // Vider les défausses
    LOGDEBUG << u8"défausses vides, ";
    m_defausseSable.vide();
    m_defausseSang.vide();

    //paquets, défausses
    LOGDEBUG << u8"reset paquets, ";
    m_paquetSable.reset();
    m_paquetSang.reset();

    //positions premier joueur et j actuel
    if (m_manche == 1) {
        m_positionJ1Manche = static_cast<Position>(rng.aleaInferieurA(NB_POSITIONS));
    }
    else {
        // Passer au joueur suivant (dans le sens horaire)
        m_positionJ1Manche = static_cast<Position>((static_cast<uint32_t>(m_positionJ1Manche) + 1) % NB_POSITIONS);

        // S'assurer que le premier joueur n'est pas éliminé
        uint32_t compteur = 0;
        while (!m_joueurs[m_positionJ1Manche].m_enJeu && compteur < NB_POSITIONS) {
            m_positionJ1Manche = static_cast<Position>((static_cast<uint32_t>(m_positionJ1Manche) + 1) % NB_POSITIONS);
            compteur++;
        }
        if (compteur == NB_POSITIONS) {
            LOGDEBUG << u8"Erreur: Impossible de démarrer la manche, plus de joueurs en jeu!"<<std::endl;
        }
    }
    
    m_positionJActuel = m_positionJ1Manche;
    m_phaseActuelle = PHASE_JETON;
    LOGDEBUG << u8"1er joueur: " << m_positionJ1Manche<< ", ";

    //reinit les effets des jetons d'influence
    //dans le jeu
    LOGDEBUG << u8"reinit influence, ";
    m_sylopsAZero = false;
    m_imposteurASix = false;
    m_sabaccInverse = false;
    m_sabaccPrime = Carte::C_INDEFINI;
    //chez les joueurs
    for (uint32_t i = 0; i < NB_POSITIONS; ++i) {        
        m_joueurs[i].m_pot = 0;
        m_joueurs[i].m_doitPasser = false;
        m_joueurs[i].m_piocheGratuite = false;
        m_joueurs[i].m_immunite = false;
        m_joueurs[i].m_de1 = 0;
        m_joueurs[i].m_de2 = 0;
    }

    // Distribution des cartes initiales
    LOGDEBUG << u8"distrib cartes, ";
    for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
        if (m_joueurs[i].m_enJeu) {
            m_joueurs[i].m_carteSable = m_paquetSable.pioche(rng);
            m_joueurs[i].m_carteSang = m_paquetSang.pioche(rng);
        }
    }

    // Placer une carte face visible sur chaque défausse    
    Carte dSable = m_paquetSable.pioche(rng);
    Carte dSang = m_paquetSang.pioche(rng);
    
    LOGDEBUG << u8"défausse cartes (Sable, Sang): (" <<dSable<<", "<<dSang<<")"<< std::endl;
    m_defausseSable.defausse(dSable);
    m_defausseSang.defausse(dSang);
    

    initTour();
}


void JeuSabacc::initTour() {
        
    m_tour++;
    LOGDEBUG << u8"début tour: " << m_tour << std::endl;
    //nouveau tour, aucun joueur n'a passé ni pioché
    for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
        m_joueurs[i].m_aPasseCeTour = false;
    }
}

void JeuSabacc::listerActionsLegales(std::vector<Action>& actions) const
{
    actions.clear();
    const JoueurSabacc& joueurActuel = m_joueurs[m_positionJActuel];

    // Si le joueur est éliminé, aucune action
    if (!joueurActuel.m_enJeu) {
        return;
    }

    switch (m_phaseActuelle) {
    case PHASE_JETON: {
        // Action de base : ne pas jouer de jeton
        actions.push_back(Action::PJ_PASSE);

        // Actions possibles avec les Jetons d'Influence possédés
        for (JetonInfluence jeton : joueurActuel.m_jetonsInfluence) {
            switch (jeton) {
            case JetonInfluence::PIOCHE_GRATUITE:   actions.push_back(Action::PJ_PIOCHE_GRATUITE); break;
            case JetonInfluence::REMBOURSEMENT_2:   actions.push_back(Action::PJ_REMBOURSEMENT_2); break; // suggérer l'action seulement si pot >0?
            case JetonInfluence::REMBOURSEMENT_3:   actions.push_back(Action::PJ_REMBOURSEMENT_3); break; // suggérer l'action seulement si pot >0?
            case JetonInfluence::TARIF_GENERAL:     actions.push_back(Action::PJ_TARIF_GENERAL); break;
            case JetonInfluence::EMBARGO:           actions.push_back(Action::PJ_EMBARGO); break;
            case JetonInfluence::DEVALORISATION:    actions.push_back(Action::PJ_DEVALORISATION); break;
            case JetonInfluence::IMMUNITE:          actions.push_back(Action::PJ_IMMUNITE); break;
            case JetonInfluence::AUDIT_GENERAL:     actions.push_back(Action::PJ_AUDIT_GENERAL); break;
            case JetonInfluence::FRAUDE_MAJEURE:    actions.push_back(Action::PJ_FRAUDE_MAJEURE); break;
            case JetonInfluence::DETOURNEMENT:      actions.push_back(Action::PJ_DETOURNEMENT); break;
            case JetonInfluence::CUISINER_LIVRES:   actions.push_back(Action::PJ_CUISINER_LIVRES); break;
            case JetonInfluence::SABACC_PRIME:      actions.push_back(Action::PJ_SABACC_PRIME); break; // Logique de lancer de dés à gérer ailleurs

            // Jetons nécessitant une cible
            case JetonInfluence::TARIF_CIBLE:
            case JetonInfluence::AUDIT_CIBLE:
            case JetonInfluence::EPUISEMENT:
            case JetonInfluence::TRANSACTION:
                for (uint32_t i = 1; i < NB_PRELATIVES; ++i) {
                    PRelative relativeTargetPos = static_cast<PRelative>(i);
                    Position absTargetPos = rel2abs(relativeTargetPos, m_positionJActuel);
                    
                    // La cible doit être en jeu et parfois avoir passé
                    if (m_joueurs[absTargetPos].m_enJeu && !m_joueurs[absTargetPos].m_immunite) {
                        bool targetAPasse = m_joueurs[absTargetPos].m_aPasseCeTour;
                        Action actionCible = Action::NB_ACTIONS; // Valeur invalide par défaut
                        switch (jeton) {
                        case JetonInfluence::TARIF_CIBLE:
                            if (relativeTargetPos == PRelative::GAUCHE) actionCible = Action::PJ_TARIF_CIBLE_G;
                            else if (relativeTargetPos == PRelative::FACE) actionCible = Action::PJ_TARIF_CIBLE_F;
                            else if (relativeTargetPos == PRelative::DROITE) actionCible = Action::PJ_TARIF_CIBLE_D;
                            break;
                        case JetonInfluence::AUDIT_CIBLE:
                            if(targetAPasse){
                                if (relativeTargetPos == PRelative::GAUCHE) actionCible = Action::PJ_AUDIT_CIBLE_G;
                                else if (relativeTargetPos == PRelative::FACE) actionCible = Action::PJ_AUDIT_CIBLE_F;
                                else if (relativeTargetPos == PRelative::DROITE) actionCible = Action::PJ_AUDIT_CIBLE_D;
                            }
                            break;
                        case JetonInfluence::EPUISEMENT:
                            if (relativeTargetPos == PRelative::GAUCHE) actionCible = Action::PJ_EPUISEMENT_G;
                            else if (relativeTargetPos == PRelative::FACE) actionCible = Action::PJ_EPUISEMENT_F;
                            else if (relativeTargetPos == PRelative::DROITE) actionCible = Action::PJ_EPUISEMENT_D;
                            break;
                        case JetonInfluence::TRANSACTION:
                            if (relativeTargetPos == PRelative::GAUCHE) actionCible = Action::PJ_TRANSACTION_G;
                            else if (relativeTargetPos == PRelative::FACE) actionCible = Action::PJ_TRANSACTION_F;
                            else if (relativeTargetPos == PRelative::DROITE) actionCible = Action::PJ_TRANSACTION_D;
                            break;
                        default: break; // Ne devrait pas arriver
                        }
                        if (actionCible != Action::NB_ACTIONS) {
                            actions.push_back(actionCible);
                        }
                    }
                }
                break;
            default: break; // JI_INDEFINI ou NB_JETONS_INFLUENCE
            }
        }
        break;
    } // Fin PHASE_JETON

    case PHASE_JETON_SABACC_PRIME_DE: {
        // Cette phase est active après avoir joué PJ_SABACC_PRIME et lancé les dés du joueur        
        actions.push_back(Action::PJSP_D1); // Choisir le résultat du dé 1
        actions.push_back(Action::PJSP_D2); // Choisir le résultat du dé 2
        break;
    } // Fin PHASE_JETON_SABACC_PRIME_DE

    case PHASE_PIOCHE: {
        // Action 1 passer
        actions.push_back(Action::PP_PASSE);

        // Action 2 piocher si argent dispo
        bool peutPayerPioche = joueurActuel.m_reserve >= 1 || joueurActuel.m_immunite;
        if (peutPayerPioche) {
            actions.push_back(Action::PP_PIOCHE_PAQUET_SABLE);
            actions.push_back(Action::PP_PIOCHE_PAQUET_SANG);
            actions.push_back(Action::PP_PIOCHE_DEFAUSSE_SABLE);
            actions.push_back(Action::PP_PIOCHE_DEFAUSSE_SANG);
        }
        break;
    } // Fin PHASE_PIOCHE

    case PHASE_DEFAUSSE: {
        // Cette phase n'est active que si le joueur a effectivement pioché une carte
        // On vérifie si une carte est en attente dans m_carteSablePiochee ou m_carteSangPiochee
        if (joueurActuel.m_carteSablePiochee != Carte::C_INDEFINI || joueurActuel.m_carteSangPiochee != Carte::C_INDEFINI) {
            // Le joueur a le choix entre garder la nouvelle carte (et défausser l'ancienne) ou défausser la nouvelle
            actions.push_back(Action::PD_GARDE_CARTE_PIOCHEE);
            actions.push_back(Action::PD_DEFAUSSE_CARTE_PIOCHEE);
        }
        break;
    }  // Fin PHASE_DEFAUSSE

    case PHASE_RESOLUTION: {
        // Actions possibles pendant la résolution : choisir la valeur des Imposteurs, les dés ayant été lancés.
        if (joueurActuel.m_carteSable == Carte::IMPOSTEUR) {
            actions.push_back(Action::PR_IMPOSTEUR_SABLE_D1);
            actions.push_back(Action::PR_IMPOSTEUR_SABLE_D2);
        }
        if (joueurActuel.m_carteSang == Carte::IMPOSTEUR) {
            actions.push_back(Action::PR_IMPOSTEUR_SANG_D1);
            actions.push_back(Action::PR_IMPOSTEUR_SANG_D2);
        }
        break;
    } // Fin PHASE_RESOLUTION

    default:
        break;
    } 

    return;
}

bool findAndRemoveJeton(JoueurSabacc& joueur, JetonInfluence jetonToRemove) {
    for (int i = 0; i < 3; ++i) {
        if (joueur.m_jetonsInfluence[i] == jetonToRemove) {
            joueur.m_jetonsInfluence[i] = JetonInfluence::JI_INDEFINI;
            return true;
        }
    }
    LOGWARNING << u8"ERREUR JI non possédé: " << jetonToRemove << std::endl;
    return false;
}

Position getActionAbsTargetPos(Action a, Position currentPos) {
    PRelative rel = PRelative::PR_INDEFINI;
    switch (a) {
    case Action::PJ_TARIF_CIBLE_G:
    case Action::PJ_AUDIT_CIBLE_G:
    case Action::PJ_EPUISEMENT_G:
    case Action::PJ_TRANSACTION_G:
        rel = PRelative::GAUCHE; break;
    case Action::PJ_TARIF_CIBLE_F:
    case Action::PJ_AUDIT_CIBLE_F:
    case Action::PJ_EPUISEMENT_F:
    case Action::PJ_TRANSACTION_F:
        rel = PRelative::FACE; break;
    case Action::PJ_TARIF_CIBLE_D:
    case Action::PJ_AUDIT_CIBLE_D:
    case Action::PJ_EPUISEMENT_D:
    case Action::PJ_TRANSACTION_D:
        rel = PRelative::DROITE; break;
    default:
        break; // Action sans cible relative
    }

    if (rel != PRelative::PR_INDEFINI) {
        return rel2abs(rel, currentPos);
    }
    return Position::P_INDEFINI; // Ne devrait pas arriver pour les actions ciblées
}

bool JeuSabacc::executeAction(Action &a, PCGAlea& rng) {
    LOGDEBUG << u8"Execute action: " << a << u8" par Joueur " << m_positionJActuel << u8" en phase " << m_phaseActuelle << std::endl;
    JoueurSabacc& joueurActuel = m_joueurs[m_positionJActuel];

    // Vérification 1: Joueur doit être en jeu
    if (!joueurActuel.m_enJeu) {
        LOGWARNING << u8"ERREUR: Joueur " << m_positionJActuel << u8" hors jeu!" << std::endl;        
        return false;
    }    
    
    // Vérification 2: Le joueur ne doit pas être forcé de passer (Embargo) sauf si l'action est de passer
    if (joueurActuel.m_doitPasser && m_phaseActuelle == PHASE_PIOCHE && a != Action::PP_PASSE) {
        LOGWARNING << u8"ERREUR executeAction: Joueur " << m_positionJActuel << u8" doit passer (Embargo) mais a tenté l'action " << a << std::endl;
        return false; 
    }

    // Vérification 3: Si la phase est DEFAUSSE, le joueur doit avoir une carte en attente
    if (m_phaseActuelle == PHASE_DEFAUSSE && joueurActuel.m_carteSablePiochee == Carte::C_INDEFINI && joueurActuel.m_carteSangPiochee == Carte::C_INDEFINI) {
        LOGWARNING << u8"ERREUR executeAction: Joueur " << m_positionJActuel << u8" est en PHASE_DEFAUSSE sans carte piochée en attente." << std::endl;
        return false; // Cas d'erreur -> false
    }

    // Vérification 4: Si la phase est RESOLUTION, le joueur doit avoir l'Imposteur correspondant et les dés lancés
    if (m_phaseActuelle == PHASE_RESOLUTION) {
        if ((a == PR_IMPOSTEUR_SABLE_D1 || a == PR_IMPOSTEUR_SABLE_D2) && (joueurActuel.m_carteSable != Carte::IMPOSTEUR || joueurActuel.m_de1 == 0)) {
            LOGWARNING << u8"ERREUR executeAction: Action " << a << u8" invalide (pas d'Imposteur Sable ou dés non lancés)." << std::endl;
            return false; // Cas d'erreur -> false
        }
        if ((a == PR_IMPOSTEUR_SANG_D1 || a == PR_IMPOSTEUR_SANG_D2) && (joueurActuel.m_carteSang != Carte::IMPOSTEUR || joueurActuel.m_de1 == 0)) {
            LOGWARNING << u8"ERREUR executeAction: Action " << a << u8" invalide (pas d'Imposteur Sang ou dés non lancés)." << std::endl;
            return false; // Cas d'erreur -> false
        }
    }

    // Vérification 5: Si la phase est PHASE_JETON_SABACC_PRIME_DE, les dés doivent être lancés
    if (m_phaseActuelle == PHASE_JETON_SABACC_PRIME_DE && joueurActuel.m_de1 == 0) {
        LOGWARNING << u8"ERREUR executeAction: Action " << a << u8" invalide (dés pour Sabacc Prime non lancés ou déjà utilisés)." << std::endl;
        return false; // Cas d'erreur -> false
    }


    bool result = true; 

    switch (m_phaseActuelle) {

    case PHASE_JETON: {
        // Phase PHASE_JETON
        switch (a) {
        case Action::PJ_PASSE:
            LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" passe la phase Jeton." << std::endl;
            m_phaseActuelle = PHASE_PIOCHE;
            break;

        case Action::PJ_PIOCHE_GRATUITE:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::PIOCHE_GRATUITE)) {
                joueurActuel.m_piocheGratuite = true;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Pioche Gratuite." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_REMBOURSEMENT_2:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::REMBOURSEMENT_2)) {
                uint32_t montantRecup = std::min(2u, joueurActuel.m_pot);
                joueurActuel.m_pot -= montantRecup;
                joueurActuel.m_reserve += montantRecup;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" récupère " << montantRecup << u8" jetons (Remboursement 2)." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_REMBOURSEMENT_3:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::REMBOURSEMENT_3)) {
                uint32_t montantRecup = std::min(3u, joueurActuel.m_pot);
                joueurActuel.m_pot -= montantRecup;
                joueurActuel.m_reserve += montantRecup;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" récupère " << montantRecup << u8" jetons (Remboursement 3)." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
			} 
            else result = false;
            break;

        case Action::PJ_TARIF_GENERAL:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::TARIF_GENERAL)) {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Tarif Général." << std::endl;
                for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
                    Position pos = static_cast<Position>(i);
                    if (pos != m_positionJActuel && m_joueurs[pos].m_enJeu && !m_joueurs[pos].m_immunite) {
                        uint32_t montantPaye = std::min(1u, m_joueurs[pos].m_reserve);
                        m_joueurs[pos].m_reserve -= montantPaye;
                        m_joueurs[pos].m_pot += montantPaye;
                        LOGDEBUG << u8"    Joueur " << pos << u8" paie 1 jeton." << std::endl;
                    }
                }
                m_phaseActuelle = PHASE_PIOCHE;
            } 
            else result = false;
            break;

        case Action::PJ_TARIF_CIBLE_G:
        case Action::PJ_TARIF_CIBLE_F:
        case Action::PJ_TARIF_CIBLE_D:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::TARIF_CIBLE)) {
                Position targetPos = getActionAbsTargetPos(a, m_positionJActuel);
                if (m_joueurs[targetPos].m_enJeu && !m_joueurs[targetPos].m_immunite) {
                    uint32_t montantPaye = std::min(2u, m_joueurs[targetPos].m_reserve);
                    m_joueurs[targetPos].m_reserve -= montantPaye;
                    m_joueurs[targetPos].m_pot += montantPaye;
                    LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Tarif Ciblé sur " << targetPos << u8". Il paie " << montantPaye << u8" jetons." << std::endl;
                }
                else {
                    LOGWARNING << u8"  ERREUR: Joueur "<<targetPos<<" ciblé hors jeu ou immunisée pour Tarif Ciblé." << std::endl;
                    result = false;
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_EMBARGO:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::EMBARGO)) {
                Position nextPos = m_positionJActuel;
                while (nextPos == m_positionJActuel || !m_joueurs[nextPos].m_enJeu) {
                    nextPos = static_cast<Position>((static_cast<uint32_t>(nextPos) + 1) % NB_POSITIONS);
                }
                if (!m_joueurs[nextPos].m_immunite) {
                    m_joueurs[nextPos].m_doitPasser = true;
                    LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Embargo sur " << nextPos << "." << std::endl;
                }
                else {
                    LOGWARNING << u8"  ERREUR: Joueur " << nextPos << " ciblé immunisée ." << std::endl;
                    result = false;
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_DEVALORISATION:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::DEVALORISATION)) {
                m_sylopsAZero = true;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Dévalorisation (Sylops=0)." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_IMMUNITE:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::IMMUNITE)) {
                joueurActuel.m_immunite = true;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Immunité." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_AUDIT_GENERAL:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::AUDIT_GENERAL)) {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Audit Général." << std::endl;
                for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
                    Position pos = static_cast<Position>(i);
                    if (pos != m_positionJActuel && m_joueurs[pos].m_enJeu && m_joueurs[pos].m_aPasseCeTour && !m_joueurs[pos].m_immunite) {
                        uint32_t montantPaye = std::min(2u, m_joueurs[pos].m_reserve);
                        m_joueurs[pos].m_reserve -= montantPaye;
                        m_joueurs[pos].m_pot += montantPaye;
                        LOGDEBUG << u8"    Joueur " << pos << u8" (a passé) paie " << montantPaye << u8" jetons." << std::endl;
                    }
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_AUDIT_CIBLE_G:
        case Action::PJ_AUDIT_CIBLE_F:
        case Action::PJ_AUDIT_CIBLE_D:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::AUDIT_CIBLE)) {
                Position targetPos = getActionAbsTargetPos(a, m_positionJActuel);
                if (targetPos != Position::P_INDEFINI && m_joueurs[targetPos].m_enJeu && m_joueurs[targetPos].m_aPasseCeTour && !m_joueurs[targetPos].m_immunite) {
                    uint32_t montantPaye = std::min(3u, m_joueurs[targetPos].m_reserve);
                    m_joueurs[targetPos].m_reserve -= montantPaye;
                    m_joueurs[targetPos].m_pot += montantPaye;
                    LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Audit Ciblé sur " << targetPos << u8" (a passé). Il paie " << montantPaye << u8" jetons." << std::endl;
                }
                else {
                    LOGWARNING << u8"  ERREUR: Cible hors jeu ou immunisée pour Audit Ciblé." << std::endl;
                    result = false;
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_FRAUDE_MAJEURE:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::FRAUDE_MAJEURE)) {
                m_imposteurASix = true;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Fraude Majeure (Imposteur=6)." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_DETOURNEMENT:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::DETOURNEMENT)) {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Détournement." << std::endl;
                uint32_t totalDetourne = 0;
                for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
                    Position pos = static_cast<Position>(i);
                    if (pos != m_positionJActuel && m_joueurs[pos].m_enJeu) {
                        uint32_t montantPris = std::min(1u, m_joueurs[pos].m_pot);
                        m_joueurs[pos].m_pot -= montantPris;
                        totalDetourne += montantPris;
                        LOGDEBUG << u8"    Prend " << montantPris << u8" jeton du pot de Joueur " << pos << "." << std::endl;
                    }
                }
                joueurActuel.m_pot += totalDetourne;
                LOGDEBUG << u8"    Total détourné dans le pot de Joueur " << m_positionJActuel << ": " << totalDetourne << "." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_CUISINER_LIVRES:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::CUISINER_LIVRES)) {
                m_sabaccInverse = true;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Cuisiner Livres (Sabacc Inverse)." << std::endl;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_EPUISEMENT_G:
        case Action::PJ_EPUISEMENT_F:
        case Action::PJ_EPUISEMENT_D:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::EPUISEMENT)) {
                Position targetPos = getActionAbsTargetPos(a, m_positionJActuel);
                if (targetPos != Position::P_INDEFINI && m_joueurs[targetPos].m_enJeu && !m_joueurs[targetPos].m_immunite) {
                    LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Épuisement sur " << targetPos << "." << std::endl;
                    JoueurSabacc& targetJoueur = m_joueurs[targetPos];
                    if (targetJoueur.m_carteSable != Carte::C_INDEFINI) m_defausseSable.defausse(targetJoueur.m_carteSable);
                    if (targetJoueur.m_carteSang != Carte::C_INDEFINI) m_defausseSang.defausse(targetJoueur.m_carteSang);
                    targetJoueur.m_carteSable = m_paquetSable.pioche(rng);
                    targetJoueur.m_carteSang = m_paquetSang.pioche(rng);
                    LOGDEBUG << u8"    Nouvelle main pour " << targetPos << ": [" << targetJoueur.m_carteSable << "|" << targetJoueur.m_carteSang << "]" << std::endl;
                }
                else {
                    LOGWARNING << u8"  Cible invalide ou immunisée pour Épuisement." << std::endl;
                    result = false;
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_TRANSACTION_G:
        case Action::PJ_TRANSACTION_F:
        case Action::PJ_TRANSACTION_D:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::TRANSACTION)) {
                Position targetPos = getActionAbsTargetPos(a, m_positionJActuel);
                if (targetPos != Position::P_INDEFINI && m_joueurs[targetPos].m_enJeu && !m_joueurs[targetPos].m_immunite) {
                    LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" applique Transaction avec " << targetPos << "." << std::endl;
                    std::swap(joueurActuel.m_carteSable, m_joueurs[targetPos].m_carteSable);
                    std::swap(joueurActuel.m_carteSang, m_joueurs[targetPos].m_carteSang);
                    LOGDEBUG << u8"    Mains échangées." << std::endl;
                }
                else {
                    LOGDEBUG << u8"  Cible invalide ou immunisée pour Transaction." << std::endl;
                    result = false;
                }
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else result = false;
            break;

        case Action::PJ_SABACC_PRIME:
            if (findAndRemoveJeton(joueurActuel, JetonInfluence::SABACC_PRIME)) {
                joueurActuel.m_de1 = rng.aleaInferieurA(6) + 1;
                joueurActuel.m_de2 = rng.aleaInferieurA(6) + 1;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" active Sabacc Prime et lance les dés: [" << joueurActuel.m_de1 << ", " << joueurActuel.m_de2 << "]" << std::endl;
                m_phaseActuelle = PHASE_JETON_SABACC_PRIME_DE; // Phase spéciale pour choisir le dé
                joueurActuel.tireDes(rng); // tirage dés
            }
            else result = false;
            break;

        default:
            // Action fournie n'est pas une action de la PHASE_JETON
            LOGWARNING << u8"  ERREUR: Action illégale (" << a << u8") pour la phase actuelle (" << m_phaseActuelle << u8")." << std::endl;
            result = false;
            break;
        } 
        break; 
    } // Fin case PHASE_JETON

    case PHASE_JETON_SABACC_PRIME_DE: {
        // Switch interne basé sur l'Action pour la PHASE_JETON_SABACC_PRIME_DE
        switch (a) {
        case Action::PJSP_D1:
            if (joueurActuel.m_de1 != 0) {
                m_sabaccPrime = static_cast<Carte>(joueurActuel.m_de1);
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" choisit le dé 1 (" << joueurActuel.m_de1 << u8") pour Sabacc Prime. Nouvelle carte prime: " << m_sabaccPrime << std::endl;
                joueurActuel.m_de1 = 0; joueurActuel.m_de2 = 0;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else {
                LOGWARNING << u8"  ERREUR: Action PJSP_D1 invalide (dés non lancés ou déjà utilisés)." << std::endl;
                result = false;
            }
            break;
        case Action::PJSP_D2:
            if (joueurActuel.m_de2 != 0) {
                m_sabaccPrime = static_cast<Carte>(joueurActuel.m_de2);
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" choisit le dé 2 (" << joueurActuel.m_de2 << u8") pour Sabacc Prime. Nouvelle carte prime: " << m_sabaccPrime << std::endl;
                joueurActuel.m_de1 = 0; joueurActuel.m_de2 = 0;
                m_phaseActuelle = PHASE_PIOCHE;
            }
            else {
                LOGWARNING << u8"  ERREUR Action PJSP_D2 invalide (dés non lancés ou déjà utilisés)." << std::endl;
                result = false;
            }
            break;
        default:
            // Action fournie n'est pas une action de la PHASE_JETON_SABACC_PRIME_DE
            LOGWARNING << u8"  ERREUR: Action illégale (" << a << u8") pour la phase actuelle (" << m_phaseActuelle << u8")." << std::endl;
            result = false;
            break;
        } 
        break; 
    } // Fin case PHASE_JETON_SABACC_PRIME_DE

    case PHASE_PIOCHE: {
        switch (a) {
        case Action::PP_PASSE:
            LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" passe la phase Pioche." << std::endl;
            joueurActuel.m_aPasseCeTour = true;
            result &= finTourJoueurActuel(rng);
            break;

        case Action::PP_PIOCHE_PAQUET_SABLE:
        case Action::PP_PIOCHE_PAQUET_SANG:
        case Action::PP_PIOCHE_DEFAUSSE_SABLE:
        case Action::PP_PIOCHE_DEFAUSSE_SANG:
        { // Bloc pour limiter la portée des variables
            bool isSable = (a == Action::PP_PIOCHE_PAQUET_SABLE || a == Action::PP_PIOCHE_DEFAUSSE_SABLE);
            bool isPaquet = (a == Action::PP_PIOCHE_PAQUET_SABLE || a == Action::PP_PIOCHE_PAQUET_SANG);
            PaquetSabacc& paquet = isSable ? m_paquetSable : m_paquetSang;
            DefausseSabacc& defausse = isSable ? m_defausseSable : m_defausseSang;
            Carte& cartePiocheeStockage = isSable ? joueurActuel.m_carteSablePiochee : joueurActuel.m_carteSangPiochee;

            bool mustPay = !joueurActuel.m_piocheGratuite;
            if (mustPay && joueurActuel.m_reserve < 1) {
                LOGWARNING << u8"  ERREUR: Joueur " << m_positionJActuel << u8" ne peut pas payer pour piocher." << std::endl;
                result = false;
                break; 
            }

            if (mustPay) {
                joueurActuel.m_reserve--;
                joueurActuel.m_pot++;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" paie 1 jeton pour piocher." << std::endl;
            }
            else {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" pioche gratuitement." << std::endl;
                joueurActuel.m_piocheGratuite = false;
            }

            Carte cartePiochee = isPaquet ? paquet.pioche(rng) : defausse.pioche();
            cartePiocheeStockage = cartePiochee;

            LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" pioche " << cartePiochee << u8" de " << (isPaquet ? "Paquet" : "Défausse") << (isSable ? " Sable." : " Sang.") << std::endl;
            m_phaseActuelle = PHASE_DEFAUSSE; // Passe à la phase de défausse
        }
        break; // Fin case PP_PIOCHE_*

        default:            
            LOGWARNING << u8"  ERREUR: Action illégale (" << a << u8") pour la phase actuelle (" << m_phaseActuelle << u8")." << std::endl;
            result = false;
            break;
        } 
        break; 
    } // Fin case PHASE_PIOCHE

    case PHASE_DEFAUSSE: {
        
        switch (a) {
        case Action::PD_DEFAUSSE_CARTE_PIOCHEE:
        {
            bool sablePioché = (joueurActuel.m_carteSablePiochee != Carte::C_INDEFINI);
            if (sablePioché) {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" défausse la carte Sable piochée (" << joueurActuel.m_carteSablePiochee << ")." << std::endl;
                m_defausseSable.defausse(joueurActuel.m_carteSablePiochee);
                joueurActuel.m_carteSablePiochee = Carte::C_INDEFINI;
            }
            else if (joueurActuel.m_carteSangPiochee != Carte::C_INDEFINI) {
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" défausse la carte Sang piochée (" << joueurActuel.m_carteSangPiochee << ")." << std::endl;
                m_defausseSang.defausse(joueurActuel.m_carteSangPiochee);
                joueurActuel.m_carteSangPiochee = Carte::C_INDEFINI;
            }
            else {
                LOGWARNING << u8" ERREUR: Action PD_DEFAUSSE_CARTE_PIOCHEE invalide (aucune carte en attente)." << std::endl;
                result = false;
            }
            result &= finTourJoueurActuel(rng);
        }
        break;

        case Action::PD_GARDE_CARTE_PIOCHEE:
        {
            bool sablePioché = (joueurActuel.m_carteSablePiochee != Carte::C_INDEFINI);
            if (sablePioché) {
                Carte ancienneCarte = joueurActuel.m_carteSable;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" garde la carte Sable piochée (" << joueurActuel.m_carteSablePiochee << u8") et défausse l'ancienne (" << ancienneCarte << ")." << std::endl;
                joueurActuel.m_carteSable = joueurActuel.m_carteSablePiochee;
                m_defausseSable.defausse(ancienneCarte);
                joueurActuel.m_carteSablePiochee = Carte::C_INDEFINI;
            }
            else if (joueurActuel.m_carteSangPiochee != Carte::C_INDEFINI) {
                Carte ancienneCarte = joueurActuel.m_carteSang;
                LOGDEBUG << u8"  Joueur " << m_positionJActuel << u8" garde la carte Sang piochée (" << joueurActuel.m_carteSangPiochee << u8") et défausse l'ancienne (" << ancienneCarte << ")." << std::endl;
                joueurActuel.m_carteSang = joueurActuel.m_carteSangPiochee;
                m_defausseSang.defausse(ancienneCarte);
                joueurActuel.m_carteSangPiochee = Carte::C_INDEFINI;
            }
            else {
                LOGWARNING << u8"  ERREUR: Action PD_GARDE_CARTE_PIOCHEE invalide (aucune carte piochée en attente)." << std::endl;
                result = false;
            }
            result &= finTourJoueurActuel(rng);
        }
        break;

        default:
            // Action fournie n'est pas une action de la PHASE_DEFAUSSE
            LOGWARNING << u8"  ERREUR: Action illégale (" << a << u8") pour la phase actuelle (" << m_phaseActuelle << u8")." << std::endl;
            result = false;
            break;
        } 
        break; 
    } // Fin case PHASE_DEFAUSSE

    case PHASE_RESOLUTION: {
        switch (a) {
        case Action::PR_IMPOSTEUR_SABLE_D1:
            if (joueurActuel.m_carteSable == Carte::IMPOSTEUR && joueurActuel.m_de1 != 0) {
                LOGDEBUG << u8"  Résolution: Joueur " << m_positionJActuel << u8" choisit Dé 1 (" << joueurActuel.m_de1 << ") pour Imposteur Sable." << std::endl;
                joueurActuel.m_carteSable = static_cast<Carte>(joueurActuel.m_de1);
                joueurActuel.m_de1 = 0;
                joueurActuel.m_de2 = 0;
                if (!(joueurActuel.m_carteSang == Carte::IMPOSTEUR))
                    result &=finTourJoueurActuel(rng);
            }
            else {
                LOGWARNING << u8"  ERREUR: Action PR_IMPOSTEUR_SABLE_D1 invalide (pas imposteur sable ou dés non lancés)." << std::endl;
                result = false;
            }
            break;
        case Action::PR_IMPOSTEUR_SABLE_D2:
            if (joueurActuel.m_carteSable == Carte::IMPOSTEUR && joueurActuel.m_de2 != 0) {
                LOGDEBUG << u8"  Résolution: Joueur " << m_positionJActuel << u8" choisit Dé 2 (" << joueurActuel.m_de2 << ") pour Imposteur Sable." << std::endl;
                joueurActuel.m_carteSable = static_cast<Carte>(joueurActuel.m_de2);
                joueurActuel.m_de1 = 0;
                joueurActuel.m_de2 = 0;
                if (!(joueurActuel.m_carteSang == Carte::IMPOSTEUR))
                    result &= finTourJoueurActuel(rng);
            }
            else {
                LOGWARNING << u8" ERREUR: Action PR_IMPOSTEUR_SABLE_D2 invalide (pas imposteur sable ou dés non lancés)." << std::endl;
                result = false;
            }
            break;
        case Action::PR_IMPOSTEUR_SANG_D1:
            if (joueurActuel.m_carteSang == Carte::IMPOSTEUR && joueurActuel.m_de1 != 0) {
                LOGDEBUG << u8"  Résolution: Joueur " << m_positionJActuel << u8" choisit Dé 1 (" << joueurActuel.m_de1 << ") pour Imposteur Sang." << std::endl;
                joueurActuel.m_carteSang = static_cast<Carte>(joueurActuel.m_de1);
                joueurActuel.m_de1 = 0;
                joueurActuel.m_de2 = 0;
                if (!(joueurActuel.m_carteSable == Carte::IMPOSTEUR))
                    result &= finTourJoueurActuel(rng);
            }
            else {
                LOGWARNING << u8"  ERREUR: Action PR_IMPOSTEUR_SANG_D1 invalide (pas imposteur sang ou dés non lancés)." << std::endl;
                result = false;
            }
            break;
        case Action::PR_IMPOSTEUR_SANG_D2:
            if (joueurActuel.m_carteSang == Carte::IMPOSTEUR && joueurActuel.m_de2 != 0) {
                LOGDEBUG << u8"  Résolution: Joueur " << m_positionJActuel << u8" choisit Dé 2 (" << joueurActuel.m_de2 << ") pour Imposteur Sang." << std::endl;
                joueurActuel.m_carteSang = static_cast<Carte>(joueurActuel.m_de2);
                joueurActuel.m_de1 = 0;
                joueurActuel.m_de2 = 0;
                if (!(joueurActuel.m_carteSable == Carte::IMPOSTEUR))
                    result &= finTourJoueurActuel(rng);
            }
            else {
                LOGWARNING << u8"  ERREUR: Action PR_IMPOSTEUR_SANG_D2 invalide (pas imposteur sang ou dés non lancés)." << std::endl;
                result = false;
            }
            break;
        default:
            // Action fournie n'est pas une action de la PHASE_RESOLUTION
            LOGWARNING << u8"  ERREUR: Action illégale (" << a << u8") pour la phase actuelle (" << m_phaseActuelle << u8")." << std::endl;
            result = false;
            break;
        } 
        break; 
    } // Fin PHASE_RESOLUTION

    default:
        // Cas où m_phaseActuelle a une valeur inattendue
        LOGWARNING << u8" Phase de jeu inconnue ou non gérée: " << static_cast<int>(m_phaseActuelle) << std::endl;
        result = false;
        break;
    } 

    // Si une action a échoué (result == false), log supplémentaire
    if (!result) {
        LOGWARNING << u8"  --> executeAction a échoué pour l'action " << a << u8" par Joueur " << m_positionJActuel << u8" en phase " << m_phaseActuelle << std::endl;
    }

    return result;
}

bool JeuSabacc::finTourJoueurActuel(PCGAlea& rng)
{
    //joueur qui finit 
    Position posJoueurQuiFinit = m_positionJActuel;
    JoueurSabacc& joueurQuiFinit = m_joueurs[posJoueurQuiFinit];    
    LOGDEBUG << u8"  finTourJoueurActuel pour Joueur " << posJoueurQuiFinit << u8" (Phase actuelle avant fin: " << m_phaseActuelle << ")" << std::endl;    
    
    //joueur suivant, tour de table complet?
    bool tourDeTableComplet = false;
    Position posJoueurSuivantEnJeu = posJoueurQuiFinit;
    while (posJoueurSuivantEnJeu == posJoueurQuiFinit || !m_joueurs[posJoueurSuivantEnJeu].m_enJeu) {
        posJoueurSuivantEnJeu = static_cast<Position>((posJoueurSuivantEnJeu + 1) % NB_POSITIONS);
    }
    if (posJoueurSuivantEnJeu == m_positionJ1Manche)
        tourDeTableComplet = true;

    switch (m_phaseActuelle) {
    case PHASE_PIOCHE: //le joueur vient de faire PP_PASSE         
    case PHASE_DEFAUSSE: //le joueur vient de faire PD_DEFAUSSE_CARTE_PIOCHEE ou PD_GARDE_CARTE_PIOCHEE        
        //passe au joueur suivant en jeu
        m_positionJActuel = posJoueurSuivantEnJeu;

        //verifie si on a fini un tour de table
        if (tourDeTableComplet)
        {
            LOGDEBUG << u8"    Tour de table complet." << std::endl;
            //regarde si tout le monde a passé son tour
            bool toutLeMondeAPasse = true;
            for (auto& j : m_joueurs) {
                if (j.m_enJeu) {
                    toutLeMondeAPasse &= j.m_aPasseCeTour;
                }
            }
            //si fin du 3eme tour ou tout le monde a passé
            //--> RESOLUTION
            if (m_tour == 3 || toutLeMondeAPasse) {
                LOGDEBUG << u8"    Condition de résolution atteinte (Tour=" << m_tour << "/3 ou ToutLeMondeAPasse=" << toutLeMondeAPasse << ")." << std::endl;
                LOGDEBUG << u8"    Passage à la PHASE_RESOLUTION. Lancement des dés pour les Imposteurs..." << std::endl;
                bool imposteurPresent = false;                
                for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
                    Position jPos = static_cast<Position>((i + m_positionJActuel) % NB_POSITIONS);
                    JoueurSabacc& j = m_joueurs[jPos];
                    if (j.m_enJeu && (j.m_carteSable == Carte::IMPOSTEUR || j.m_carteSang == Carte::IMPOSTEUR)) {
                        j.tireDes(rng); // Lance les dés
                        LOGDEBUG << u8"      Joueur " << static_cast<Position>(jPos) << u8" lance les dés pour Imposteur: [" << j.m_de1 << ", " << j.m_de2 << "]" << std::endl;
                        LOGDEBUG << u8"      Joueur " << static_cast<Position>(jPos) << u8"devient joueur actuel" << std::endl;
                        //premier joueur avec imposteurs devient joueur actuel
                        m_positionJActuel = jPos;                                                    
                        imposteurPresent = true;
                        break;
                    }
                }

                m_phaseActuelle = PHASE_RESOLUTION;

                // Si aucun imposteur n'est présent, on peut aller directement à la logique de fin de manche.
                if (!imposteurPresent) {
                    LOGDEBUG << u8"    Aucun Imposteur à résoudre. Application directe de la résolution de manche." << std::endl;
                    finManche(); // Applique gains/pertes/éliminations
                    if (!m_jeuTermine) {
                        LOGDEBUG << u8"    Préparation de la manche suivante..." << std::endl;
                        initManche(rng); // Prépare la manche suivante (MISE A JOUR: m_manche, m_tour, m_positionJActuel, m_phaseActuelle etc.)
                    }
                    else {
                        LOGDEBUG << u8"    Le jeu est terminé après résolution." << std::endl;
                    }
                }
                else {
                    LOGDEBUG << u8"    Le joueur " << m_positionJActuel << " commence la résolution des Imposteurs." << std::endl;
                }
            }
            else {
                //sinon c un nouveau tour normal
                LOGDEBUG << u8"    Début du tour suivant." << std::endl;
                initTour(); // MISE A JOUR: m_tour, reset m_aPasseCeTour
                // MISE A JOUR: m_phaseActuelle (remis à JETON par initTour implicitement ou explicitement)
                m_phaseActuelle = PHASE_JETON; // Assure qu'on recommence par la phase jeton
                // Réinitialise aussi m_doitPasser pour le nouveau tour (sauf si un nouvel embargo est joué)
                for (uint32_t i = 0; i < NB_POSITIONS; ++i) m_joueurs[i].m_doitPasser = false;            
            }
        }
        else {
            // Tour de table non complet, on passe juste au joueur suivant                 
            m_phaseActuelle = PHASE_JETON;
            // Réinitialise doitPasser pour le joueur qui vient de jouer (au cas où il était sous embargo)
            joueurQuiFinit.m_doitPasser = false;
        }
        break; //Fin de PHASE_PIOCHE et PHASE_DEFAUSSE
    
    case PHASE_RESOLUTION: // Un joueur vient de finir de choisir la valeur de son/ses Imposteur(s)
    
        //passe au joueur suivant en jeu
        m_positionJActuel = posJoueurSuivantEnJeu;
        LOGDEBUG << u8"    --> Résolution Imposteur: Joueur suivant: " << m_positionJActuel << std::endl;

        //verifie si on a fini un tour de table
        if (tourDeTableComplet)
        {
            LOGDEBUG << u8"    Tour de table de résolution des Imposteurs terminé." << std::endl;
            // Tous les imposteurs ont été résolus (ou il n'y en avait pas).
            // Appliquer la logique de fin de manche (calcul scores, pénalités, éliminations).
            finManche();

            if (!m_jeuTermine) {
                // Si le jeu n'est pas terminé, on démarre une nouvelle manche.
                LOGDEBUG << u8"    Préparation de la manche suivante..." << std::endl;
                initManche(rng);
            }
            else {
                LOGDEBUG << u8"    Le jeu est terminé après résolution." << std::endl;
            }

        }
        else {
            // Le tour de table de résolution n'est pas fini.
            // cherche le prochain joueur avec un imposteur non résolu et tire les dés
            bool imposteurPresent = false;
            for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
                Position jPos = static_cast<Position>((i + m_positionJActuel) % NB_POSITIONS);
                JoueurSabacc& j = m_joueurs[jPos];
                if (j.m_enJeu && (j.m_carteSable == Carte::IMPOSTEUR || j.m_carteSang == Carte::IMPOSTEUR)) {
                    j.tireDes(rng); // Lance les dés
                    LOGDEBUG << u8"      Joueur " << static_cast<Position>(jPos) << u8" lance les dés pour Imposteur: [" << j.m_de1 << ", " << j.m_de2 << "]" << std::endl;
                    LOGDEBUG << u8"      Joueur " << static_cast<Position>(jPos) << u8"devient joueur actuel" << std::endl;
                    //premier joueur avec imposteurs devient joueur actuel
                    m_positionJActuel = jPos;
                    imposteurPresent = true;
                    break;
                }
            }

            // Si aucun imposteur n'est présent, on peut aller directement à la logique de fin de manche.
            if (!imposteurPresent) {
                LOGDEBUG << u8"    Aucun Imposteur à résoudre. Application directe de la résolution de manche." << std::endl;
                finManche(); // Applique gains/pertes/éliminations
                if (!m_jeuTermine) {
                    LOGDEBUG << u8"    Préparation de la manche suivante..." << std::endl;
                    initManche(rng); // Prépare la manche suivante (MISE A JOUR: m_manche, m_tour, m_positionJActuel, m_phaseActuelle etc.)
                }
                else {
                    LOGDEBUG << u8"    Le jeu est terminé après résolution." << std::endl;
                }
            }
            else {
                LOGDEBUG << u8"    Le joueur " << m_positionJActuel << " commence la résolution des Imposteurs." << std::endl;
            }
        }
        break;// Fin de PHASE_RESOLUTION
    
    default:
        LOGWARNING << u8"ERREUR finTourJoueurActuel: Appel depuis une phase inattendue (" << m_phaseActuelle << ")!" << std::endl;
        return false; // Erreur        
    }
   
    LOGDEBUG << u8"  finTourJoueurActuel terminé. Nouvelle phase: " << m_phaseActuelle << ", Joueur actuel: " << m_positionJActuel << std::endl;
    return true; // Succès
}

bool JeuSabacc::finManche()
{
    LOGDEBUG << "Jeu terminé, calcul des scores";
    // chaque sylop copie l'autre carte même si c'est un sylop aussi

    // calcule un score: abs(diff entre les valeurs de carte) *100 + somme des valeurs de cartes
    // trie les joueurs par ce score

    //rang 1 des joueurs: récupère tous les jetons de pot
    
    //rangs suivant: si paire de cartes, perd pot et retire de la réserve max(1, abs(diff entre les valeurs de carte))

    //vide les pots

    //joueurs si reserve==0 éliminés

    //initialise nouvelle manche

    return true;
}


std::ostream& operator<<(std::ostream& os, const JetonInfluence& j)
{
	switch (j) {
	    case JetonInfluence::AUDIT_CIBLE: os << u8"Audit ciblé"; break;
        case JetonInfluence::AUDIT_GENERAL: os << u8"Audit général"; break;
        case JetonInfluence::CUISINER_LIVRES: os << u8"Cuisiner livres"; break;
        case JetonInfluence::DETOURNEMENT: os << u8"Détournement"; break;
        case JetonInfluence::DEVALORISATION: os << u8"Dévalorisation"; break;
        case JetonInfluence::EMBARGO: os << u8"Embargo"; break;
        case JetonInfluence::EPUISEMENT: os << u8"Epuisement"; break;
        case JetonInfluence::FRAUDE_MAJEURE: os << u8"Fraude Maj."; break;
        case JetonInfluence::IMMUNITE: os << u8"Immunité"; break;
        case JetonInfluence::JI_INDEFINI: os << u8"Indéfini"; break;
        case JetonInfluence::PIOCHE_GRATUITE: os << u8"Pioche Gratuite"; break;
        case JetonInfluence::REMBOURSEMENT_2: os << u8"Remboursement "; break;
        case JetonInfluence::REMBOURSEMENT_3: os << u8"Remboursement Suppl."; break;
        case JetonInfluence::SABACC_PRIME: os << u8"Sabacc Prime"; break;
        case JetonInfluence::TARIF_CIBLE: os << u8"Tarif ciblé"; break;
        case JetonInfluence::TARIF_GENERAL: os << u8"Tarif général"; break;
        case JetonInfluence::TRANSACTION: os << u8"Transaction"; break;
	}
	return os;
}

std::ostream& operator<<(std::ostream& os, const Carte& c)
{
    switch (c) {
        case Carte::C1: os << u8"1"; break;
        case Carte::C2: os << u8"2"; break;
        case Carte::C3: os << u8"3"; break;
        case Carte::C4: os << u8"4"; break;
        case Carte::C5: os << u8"5"; break;
        case Carte::C6: os << u8"6"; break;
        case Carte::C_INDEFINI: os << u8"Indéfini"; break;
        case Carte::IMPOSTEUR: os << u8"Imp."; break;
        case Carte::SYLOP: os << u8"Syl."; break;
    }
    return os;
}

std::ostream& operator<<(std::ostream& os, const Position& p)
{
    switch (p) {
        case Position::E: os << u8"E"; break;
        case Position::N: os << u8"N"; break;
        case Position::S: os << u8"S"; break;
        case Position::O: os << u8"O"; break;
        case Position::P_INDEFINI: os << "Indéfini"; break;
    }
    return os;
}

std::ostream& operator<<(std::ostream& os, const PRelative& p)
{
    switch (p) {
    case PRelative::MOI: os << u8"M"; break;
    case PRelative::GAUCHE: os << u8"G"; break;
    case PRelative::FACE: os << u8"F"; break;
    case PRelative::DROITE: os << u8"D"; break;
    case PRelative::PR_INDEFINI: os << u8"Indéfini"; break;
    default: os << u8"Inconnu"; break;
    }
    return os;
}

PRelative abs2rel(const Position p, const Position maPosition)
{
    return static_cast<PRelative>((p - maPosition + NB_POSITIONS) % NB_POSITIONS);
}

Position rel2abs(const PRelative p, const Position maPosition)
{
    return static_cast<Position>((p + maPosition) % NB_POSITIONS);
}

std::ostream& operator<<(std::ostream& os, const PhaseTour& p)
{
    switch (p) {
        case PHASE_JETON:               os << u8"JETON";          break;
        case PHASE_JETON_SABACC_PRIME_DE: os << u8"JETON PRIME DÉ"; break;
        case PHASE_PIOCHE:              os << u8"PIOCHE";         break;
        case PHASE_DEFAUSSE:            os << u8"DEFAUSSE";       break;
        case PHASE_RESOLUTION:          os << u8"RESOLUTION";     break;
        default:                        os << u8"INCONNUE";       break;
    }
    return os;
}

std::ostream& operator<<(std::ostream& os, const JoueurSabacc& joueur)
{
    // Ligne 1: État, cartes, réserve et pot avec tabulations pour alignement
    os << (joueur.m_enJeu ? u8"\033[32m[En jeu]\033[0m\t" : u8"\033[31m[Éliminé]\t\033[0m")
        << u8"Main:[\033[33m" << joueur.m_carteSable << " | \033[31m" << joueur.m_carteSang << "\033[0m]\t"
        << u8"R:" << joueur.m_reserve << u8"\tP:" << joueur.m_pot << "\t";

    // Affichage des effets actifs
    if (joueur.m_doitPasser || joueur.m_immunite || joueur.m_piocheGratuite) {
        os << u8"Effets:";
        if (joueur.m_doitPasser)     os << u8"[Passer]";
        if (joueur.m_immunite)       os << u8"[Immunité]";
        if (joueur.m_piocheGratuite) os << u8"[Pioche Gratuite]";
        os << u8"\t";
    }
    else {
        os << u8"\t\t";
    }

    // Affichage des jetons d'influence sur la même ligne
    os << u8"JI:";
    for (int i = 0; i < 3; ++i) {
        if (joueur.m_jetonsInfluence[i] != JetonInfluence::JI_INDEFINI) {
            os << u8" [" << joueur.m_jetonsInfluence[i] << u8"]";
        }
    }

    return os;
}

std::ostream& operator<<(std::ostream& os, const Action& action) {
    os << "ACTION [";
    switch (action) {
            // --- Actions de la Phase Jeton (PJ_) ---
        case Action::PJ_PASSE:                  os << u8"PJ: Passe"; break;
        case Action::PJ_PIOCHE_GRATUITE:        os << u8"PJ: Pioche Gratuite"; break;
        case Action::PJ_REMBOURSEMENT_2:        os << u8"PJ: Remboursement 2"; break;
        case Action::PJ_REMBOURSEMENT_3:        os << u8"PJ: Remboursement 3"; break;
        case Action::PJ_TARIF_GENERAL:          os << u8"PJ: Tarif Général"; break;
        case Action::PJ_TARIF_CIBLE_G:          os << u8"PJ: Tarif Ciblé (G)"; break;
        case Action::PJ_TARIF_CIBLE_F:          os << u8"PJ: Tarif Ciblé (F)"; break;
        case Action::PJ_TARIF_CIBLE_D:          os << u8"PJ: Tarif Ciblé (D)"; break;
        case Action::PJ_EMBARGO:                os << u8"PJ: Embargo"; break;
        case Action::PJ_DEVALORISATION:         os << u8"PJ: Dévalorisation"; break;
        case Action::PJ_IMMUNITE:               os << u8"PJ: Immunité"; break;
        case Action::PJ_AUDIT_GENERAL:          os << u8"PJ: Audit Général"; break;
        case Action::PJ_AUDIT_CIBLE_G:          os << u8"PJ: Audit Ciblé (G)"; break;
        case Action::PJ_AUDIT_CIBLE_F:          os << u8"PJ: Audit Ciblé (F)"; break;
        case Action::PJ_AUDIT_CIBLE_D:          os << u8"PJ: Audit Ciblé (D)"; break;
        case Action::PJ_FRAUDE_MAJEURE:         os << u8"PJ: Fraude Majeure"; break;
        case Action::PJ_DETOURNEMENT:           os << u8"PJ: Détournement"; break;
        case Action::PJ_CUISINER_LIVRES:        os << u8"PJ: Cuisiner Livres"; break;
        case Action::PJ_EPUISEMENT_G:           os << u8"PJ: Épuisement (G)"; break;
        case Action::PJ_EPUISEMENT_F:           os << u8"PJ: Épuisement (F)"; break;
        case Action::PJ_EPUISEMENT_D:           os << u8"PJ: Épuisement (D)"; break;
        case Action::PJ_TRANSACTION_G:          os << u8"PJ: Transaction (G)"; break;
        case Action::PJ_TRANSACTION_F:          os << u8"PJ: Transaction (F)"; break;
        case Action::PJ_TRANSACTION_D:          os << u8"PJ: Transaction (D)"; break;
        case Action::PJ_SABACC_PRIME:           os << u8"PJ: Sabacc Prime"; break;
        case Action::PJSP_D1:					os << u8"PJ Sabacc Prime: Dé 1"; break;
        case Action::PJSP_D2:					os << u8"PJ Sabacc Prime: Dé 2"; break;

            // --- Actions de la Phase Pioche (PP_) ---
        case Action::PP_PIOCHE_PAQUET_SANG:     os << u8"PP: Pioche Paquet Sang"; break;
        case Action::PP_PIOCHE_PAQUET_SABLE:    os << u8"PP: Pioche Paquet Sable"; break;
        case Action::PP_PIOCHE_DEFAUSSE_SANG:   os << u8"PP: Pioche Défausse Sang"; break;
        case Action::PP_PIOCHE_DEFAUSSE_SABLE:  os << u8"PP: Pioche Défausse Sable"; break;
        case Action::PP_PASSE:                  os << u8"PP: Passe "; break;

            // --- Actions de la Phase Défausse (PD_) ---
        case Action::PD_DEFAUSSE_CARTE_PIOCHEE: os << u8"PD: Défausse Carte Piochée"; break;
        case Action::PD_GARDE_CARTE_PIOCHEE:    os << u8"PD: Garde Carte Piochée"; break;

            // --- Actions de la Phase RESOLUTION (PR_) ---
        case Action::PR_IMPOSTEUR_SANG_D1: os  << u8"PR: Imposteur Sang Dé 1"; break;
        case Action::PR_IMPOSTEUR_SANG_D2: os  << u8"PR: Imposteur Sang Dé 2"; break;
        case Action::PR_IMPOSTEUR_SABLE_D1: os << u8"PR: Imposteur Sable Dé 1"; break;
        case Action::PR_IMPOSTEUR_SABLE_D2: os << u8"PR: Imposteur Sable Dé 2"; break;

                       // --- Cas par défaut (ne devrait pas arriu8ver si NB_ACTIONS est bien géré) ---
        default:                                os << u8"Inconnue (" << static_cast<int>(action) << ")"; break;
    }
    os << "]";
    return os;
}

std::ostream& operator<<(std::ostream& os, const JeuSabacc& jeu)
{
    // Entête avec infos générales du jeu, bien tabulé
    os << u8"SABACC Manche: " << jeu.m_manche << u8" Tour: " << jeu.m_tour << u8"/3 Phase: ";

    os << jeu.m_phaseActuelle;
    os << std::endl;

    // Info paquets avec tabulations pour alignement
    os << u8"Paquets: \033[33m Sable: " << jeu.m_paquetSable.getNbCartes()
        << u8" \033[31m Sang: " << jeu.m_paquetSang.getNbCartes()
        << u8"\033[0m \t| Défausses: \033[33m Sable: " << jeu.m_defausseSable.regarde() << " (" << jeu.m_defausseSable.getNbCartes()<<") "
        << u8"\033[31m Sang: " << jeu.m_defausseSang.regarde()<<" ("<<jeu.m_defausseSang.getNbCartes()<<") " << "\033[0m" << std::endl;

    // Effets globaux actifs, alignés
    os << u8"Effets globaux:\t";
    bool hasGlobalEffects = false;
    if (jeu.m_sylopsAZero) {
        os << u8"[Sylops=0]\t";
        hasGlobalEffects = true;
    }
    if (jeu.m_imposteurASix) {
        os << u8"[Imposteur=6]\t";
        hasGlobalEffects = true;
    }
    if (jeu.m_sabaccInverse) {
        os << u8"[Sabacc Inverse]\t";
        hasGlobalEffects = true;
    }
    if (jeu.m_sabaccPrime != Carte::C_INDEFINI) {
        os << u8"[Sabacc Prime=" << jeu.m_sabaccPrime << u8"]\t";
        hasGlobalEffects = true;
    }
    if (!hasGlobalEffects) {
        os << u8"Aucun";
    }
    os << std::endl;

    // Affichage des joueurs
    os << u8"--- Joueurs ---" << std::endl;
    for (uint32_t i = 0; i < NB_POSITIONS; ++i) {
        Position pos = static_cast<Position>(i);
        os << pos << (pos == jeu.m_positionJActuel ? u8"(*)" : u8"   ") << u8"\t";
        os << jeu.m_joueurs[i] << std::endl;
    }

    return os;
}